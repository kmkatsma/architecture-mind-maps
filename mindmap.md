# System Engineering

## Methodology

- Organization - [The Software Studio](https://www.forbes.com/sites/cognitiveworld/2019/08/28/agile-and-the-studio-model/?sh=6ed0f34778de)
  - Reading
    - [End Of Agile](https://www.forbes.com/sites/cognitiveworld/2019/08/23/the-end-of-agile/?sh=4364c0e22071)
  - Theory
    - Software As Model Building
    - Building Shared Understanding
      - Architect Responsibility
      - Stable Teams
      - Prefer Overcommunication over Under
    - Minimize Communication For Any Given Team
      - Communication Theory implies a Max Effective Team Size
      - Adding person increases channels exponentially
  - Architect as Director/Editor
    - If Everyone Owns, No One Does
    - Singular Vision
    - Not The Domain Expert
    - Defines Volatilities & Boundaries
      - High Level (Strategic)
      - Libaries
        - Boundaries - Stategies
        - Class-Level - Tactical
  - The Customer Is Lying To You
    - Is Not The Expert
    - Developers Are The Domain Experts
  - Creative Teams
    - Assigned Elements of Design
    - Own the Implemation/Tactical design
- System (Strategic) Design
  - Define Volatilities
    - Dependencies
    - Technologies
  - Define Boundaries (Bounded Contexts)
    - What Can A Team Own
      - Minimize Cognitive Load
      - Architectural Concern - Conway's Law
    - Maximize Cohesion
      - Keeps Things That Change Together
      - Minimizes Cognitive Load
    - Minimize Coupling
      - Minimizes Impact/Risk Of Change
      - Asynchronous Queues Betwen Contexts Where Possible
      - Defined, Backwards Compatible Contracts
      - Single Shared or Autogenerated DTOs
  - Communication Boundaries
    - Most Physical Isolation Can Happen Later
    - Physical Isolation Required When:
      - Scaling units of contexts differ greatly
      - Scaling demands of individual contexts are very large (e.g., massively parallel)
  - [C4 Diagrams](https://github.com)
  - Library Types
    - appliation
    - fx - utilities
      - what is it?
        - reusable utilities
        - plumbing
      - sub-types
        - core - across layers
        - models - base models
        - ui - fe only
        - service - server only
    - system
      - what is it?
        - system level behavior
        - depends on fx
        - only supports system
        - implements system level services
        - no value alone
      - sub-types
        - access
        - domain
        - handler
        - models
        - ui
    - feature
      - what is it?
        - implements application logic
        - depends on fx & system
      - sub-types
        - access
        - app shell
        - domain
        - models
        - ui
- Project Design
  - After System Design
  - Define The Steps/Plan
    - Define Dependencies
    - What Can Be Released When
    - Sprints Are Arbitrary, Plan Is Not
    - Major Integration Points As Milestones
  - Assign Work To Teams
    - Bounded Contexts To Teams
      - fx
      - system
      - features
    - Components/Services To Individuals
- Service (Tactical) Design
  - Controllers are Plumbing!
  - Service Types
    - Managers/Handlers
    - Engines/Domain
    - Access
    - Fx
  - Read/Write Separation
    - Even If All Same Source
    - Allows Customization of Read Model
  - Implement Barriers
    - What Can Call What
    - Ideally Automated
  - Communication
    - In Process
    - Within System
      - RPC for UI/Sync
      - In/Out Process Messaging
    - Outside System
      - REST for External Interfaces
  - Define Process
    - Business Use Cases
      - Use Business Language
    - Commands - Request
    - Events - After Command
    - Define Data Structures (Types)
      - Embed Rules Into Types
  - Service Method Design
    - 'Service As Pipeline'
    - Reads At Start
    - Writes At End
    - Pipeline Steps Transform Types
    - Immutability As Principle
    - Functional In Principle - No Side
      Effects
    - Service Patterns
      - Transaction Script Is Fine To Start
      - Migrate to Rich Domain
        - When Transaction Script Too Large
        - When Behaviors Can Be Abstracted Or Shared
      - Builder Pattern
        - Load Data, Apply Rules
        - Self Contained
      - Actor Pattern
        - State-Centric Scenarios
        - Stateful Real-Life Counterparts
        - Built In Caching
        - Highly Parallel
- Change Management

  - Source Control
    - Use Monorepo To
      - Always Latest Dependencies
      - Reduce Friction
      - Increase Visibility
  - Integrating Change
    - Cliche - Early And Often
    - Change-Driven Design
      - Design For Units Of Change
      - First Class Feature Flags
        - Provide 'Seams'
        - Automated Cleanup
        - Observability of Features In Use
    - Minimize Branching
      - Trunk-Based Development
      - Small Changes

- Documentation
  - Architectural Decisions
    - In the Repo as MD
    - Common Formats
  - Code Level
    - Auto-Generated Where Possible
    - Tests Are Form of Doc

## UI

- Reading
  - [Atomic Design](https://atomicdesign.bradfrost.com/)
  - [Shell Library Pattern](https://indepth.dev/posts/1117/the-shell-library-patterns-with-nx-and-monorepo-architectures)
- Framework is a volatility
  - But...Framework is Valuable
  - Abstract What You Can, but Don't Wrap
    - Too Much Work To Wrap
    - With Abstraction Could Automate Conversions
  - Ideal is Thin Framework Over Standards
    - Framework + Web Components
  - IsolateDomain From Framework
  - Fx is Tied to Framework
- Fx/Core
  - Utilities/Services
  - State Management Wrappers
  - Not Components
- System/Feature Library
  - State Elements
    - System 'Shared/Standard' state
    - Feature-specific state
    - Can be embedded within Component
  - Structure
    - Atoms
      - Individual Elements
      - Can't be Broken Down
      - Typically Won't Plug Into State
    - Molecules
      - Groups Of Atoms
      - Ex: Data Table With Search/paging
      - Typically Wont Plug Into State
    - Organisms
      - Group Of Atoms And Molecules
      - Entity Edit
      - Can Use System/Featur State
    - Pages
      - Typically Feature-Specific
      - Domain Behavior In Services
      - Can Use System/Feature State
    - Templates
      - Abstract Pages
        - Layout
        - Containers
      - Can Have System/Feature State
    - Services (Domain)
      - Separate From Components
      - Types
        - Component-Specific
        - Shared (Cross Component)
- Design System
  - As close to Live as Possible
  - Storybook
- Pattern Library

## Infrastructure

- Reading
- Define Volatilities
  - Cloud is Not
    - Data Will Not Move
    - Least Common Denominator Loses Value
  - Will Always Require Adaptor Layer
- CI Tool
  - Is A Volatility
    - Minimize Surface Area
      - Pipelines
      - Variables
  - Examples
    - Azure DevOps
    - Github Actions
    - Circle CI
    - Travis CI
- Definition Framework
  - Should Be A Language
    - Conditions Exist
    - Repetition Exists
  - Is A Volatility
    - Be Sure It Will Survive
    - Rolling Own Can Be Worth It
  - Examples
    - Terraform
    - Pulumi
    - AWS
    - Bicep
    - Custom
      - Powershell
      - API Wrappers
- Reliability/Redundancy
  - Define Levels
  - The "Over Time" Aspect of Infra
  - Baked into Definitions
- Observability
  - APM
  - Logging/Monitoring
- Security
  - Evaluate/Use Cloud Tooling
  - RBAC Baked Into Definitions
  - AuthZ/AuthN Baked Into Definition

## Testing

- Reading
- Testing Pyramid
  - Unit
    - Minimize Mocking
    - Use Fakes Where Possible
      - Custom
      - Tools like Sqlite
    - Make It Easy - Frameworks/Utils
    - Don't Use Coverage
      - Goodheart's Law
      - Has To Come From Within
    - Keep Them Simple
      - Must Be Understandable
      - Ideally Only One 'Thing'
    - 'Black Box'
      - Based On Behavior
      - Minimizes Brittleness
      - Rules of Thumb
        - Limit Spies
        - Limit Private method calls
  - Integration
    - Identify The Seams
    - Define Levels Of Isolation
    - Test Data Requirements
    - Security Requirements
  - End To End
    - Identify Scenarios
    - Levels Of Isolation
    - Test Data Requirements
    - Security Requirements
- Tooling
  - Is a volatility
  - Minimize Sets of Tools
    - Cypress For All?
- Data Generation
  - Anonymization From Prod
  - Synthetic
- Test Engineers
  - Own the Frameworks
  - Generation Of Data

## Data Engineering

- Reading
  - [Modern Data Stack](https://blog.getdbt.com/future-of-the-modern-data-stack/)
- Apply Software Engineering Principles
  - Source Control
  - Change Control
  - Testability
  - Productionizing Notebooks
- Orchestration Techniques
  - How To Sequence Depdendencies?
  - Write Your Own
    - ADF Pipelines
    - Functions
    - 'Master' Notebooks
- Tooling Is A Volatility
  - Carefully Pick Tools/Dependencies
  - Ideal: Standards-Based/Open Source
  - Modern Stack Options
    - Ingestion: Fivetran, Stitch
    - Warehousing: Snowflake, Bigquery, Redshift
    - Transformation: dbt
    - BI: Looker, Mode, Periscope, Chartio, Metabase, Redash
